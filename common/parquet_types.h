/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef parquet_TYPES_H
#define parquet_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>
#include <thrift/cxxfunctional.h>

namespace parquet {

struct Type {
  enum type {
    BOOLEAN = 0,
    INT32 = 1,
    INT64 = 2,
    INT96 = 3,
    FLOAT = 4,
    DOUBLE = 5,
    BYTE_ARRAY = 6,
    FIXED_LEN_BYTE_ARRAY = 7
  };
};

extern const std::map<int, const char*> _Type_VALUES_TO_NAMES;

struct ConvertedType {
  enum type {
    UTF8 = 0,
    MAP = 1,
    MAP_KEY_VALUE = 2,
    LIST = 3,
    ENUM = 4,
    DECIMAL = 5,
    DATE = 6,
    TIME_MILLIS = 7,
    TIME_MICROS = 8,
    TIMESTAMP_MILLIS = 9,
    TIMESTAMP_MICROS = 10,
    UINT_8 = 11,
    UINT_16 = 12,
    UINT_32 = 13,
    UINT_64 = 14,
    INT_8 = 15,
    INT_16 = 16,
    INT_32 = 17,
    INT_64 = 18,
    JSON = 19,
    BSON = 20,
    INTERVAL = 21
  };
};

extern const std::map<int, const char*> _ConvertedType_VALUES_TO_NAMES;

struct FieldRepetitionType {
  enum type { REQUIRED = 0, OPTIONAL = 1, REPEATED = 2 };
};

extern const std::map<int, const char*> _FieldRepetitionType_VALUES_TO_NAMES;

struct Encoding {
  enum type {
    PLAIN = 0,
    PLAIN_DICTIONARY = 2,
    RLE = 3,
    BIT_PACKED = 4,
    DELTA_BINARY_PACKED = 5,
    DELTA_LENGTH_BYTE_ARRAY = 6,
    DELTA_BYTE_ARRAY = 7,
    RLE_DICTIONARY = 8
  };
};

extern const std::map<int, const char*> _Encoding_VALUES_TO_NAMES;

struct CompressionCodec {
  enum type {
    UNCOMPRESSED = 0,
    SNAPPY = 1,
    GZIP = 2,
    LZO = 3,
    BROTLI = 4,
    LZ4 = 5,
    ZSTD = 6
  };
};

extern const std::map<int, const char*> _CompressionCodec_VALUES_TO_NAMES;

struct PageType {
  enum type {
    DATA_PAGE = 0,
    INDEX_PAGE = 1,
    DICTIONARY_PAGE = 2,
    DATA_PAGE_V2 = 3
  };
};

extern const std::map<int, const char*> _PageType_VALUES_TO_NAMES;

struct BoundaryOrder {
  enum type { UNORDERED = 0, ASCENDING = 1, DESCENDING = 2 };
};

extern const std::map<int, const char*> _BoundaryOrder_VALUES_TO_NAMES;

class Statistics;

class StringType;

class UUIDType;

class MapType;

class ListType;

class EnumType;

class DateType;

class NullType;

class DecimalType;

class MilliSeconds;

class MicroSeconds;

class TimeUnit;

class TimestampType;

class TimeType;

class IntType;

class JsonType;

class BsonType;

class LogicalType;

class SchemaElement;

class DataPageHeader;

class IndexPageHeader;

class DictionaryPageHeader;

class DataPageHeaderV2;

class PageHeader;

class KeyValue;

class SortingColumn;

class PageEncodingStats;

class ColumnMetaData;

class ColumnChunk;

class RowGroup;

class TypeDefinedOrder;

class ColumnOrder;

class PageLocation;

class OffsetIndex;

class ColumnIndex;

class FileMetaData;

typedef struct _Statistics__isset {
  _Statistics__isset()
      : max(false),
        min(false),
        null_count(false),
        distinct_count(false),
        max_value(false),
        min_value(false) {}
  bool max : 1;
  bool min : 1;
  bool null_count : 1;
  bool distinct_count : 1;
  bool max_value : 1;
  bool min_value : 1;
} _Statistics__isset;

class Statistics : public virtual ::apache::thrift::TBase {
 public:
  Statistics(const Statistics&);
  Statistics& operator=(const Statistics&);
  Statistics()
      : max(),
        min(),
        null_count(0),
        distinct_count(0),
        max_value(),
        min_value() {}

  virtual ~Statistics() throw();
  std::string max;
  std::string min;
  int64_t null_count;
  int64_t distinct_count;
  std::string max_value;
  std::string min_value;

  _Statistics__isset __isset;

  void __set_max(const std::string& val);

  void __set_min(const std::string& val);

  void __set_null_count(const int64_t val);

  void __set_distinct_count(const int64_t val);

  void __set_max_value(const std::string& val);

  void __set_min_value(const std::string& val);

  bool operator==(const Statistics& rhs) const {
    if (__isset.max != rhs.__isset.max)
      return false;
    else if (__isset.max && !(max == rhs.max))
      return false;
    if (__isset.min != rhs.__isset.min)
      return false;
    else if (__isset.min && !(min == rhs.min))
      return false;
    if (__isset.null_count != rhs.__isset.null_count)
      return false;
    else if (__isset.null_count && !(null_count == rhs.null_count))
      return false;
    if (__isset.distinct_count != rhs.__isset.distinct_count)
      return false;
    else if (__isset.distinct_count && !(distinct_count == rhs.distinct_count))
      return false;
    if (__isset.max_value != rhs.__isset.max_value)
      return false;
    else if (__isset.max_value && !(max_value == rhs.max_value))
      return false;
    if (__isset.min_value != rhs.__isset.min_value)
      return false;
    else if (__isset.min_value && !(min_value == rhs.min_value))
      return false;
    return true;
  }
  bool operator!=(const Statistics& rhs) const { return !(*this == rhs); }

  bool operator<(const Statistics&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Statistics& a, Statistics& b);

inline std::ostream& operator<<(std::ostream& out, const Statistics& obj) {
  obj.printTo(out);
  return out;
}

class StringType : public virtual ::apache::thrift::TBase {
 public:
  StringType(const StringType&);
  StringType& operator=(const StringType&);
  StringType() {}

  virtual ~StringType() throw();

  bool operator==(const StringType& /* rhs */) const { return true; }
  bool operator!=(const StringType& rhs) const { return !(*this == rhs); }

  bool operator<(const StringType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringType& a, StringType& b);

inline std::ostream& operator<<(std::ostream& out, const StringType& obj) {
  obj.printTo(out);
  return out;
}

class UUIDType : public virtual ::apache::thrift::TBase {
 public:
  UUIDType(const UUIDType&);
  UUIDType& operator=(const UUIDType&);
  UUIDType() {}

  virtual ~UUIDType() throw();

  bool operator==(const UUIDType& /* rhs */) const { return true; }
  bool operator!=(const UUIDType& rhs) const { return !(*this == rhs); }

  bool operator<(const UUIDType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UUIDType& a, UUIDType& b);

inline std::ostream& operator<<(std::ostream& out, const UUIDType& obj) {
  obj.printTo(out);
  return out;
}

class MapType : public virtual ::apache::thrift::TBase {
 public:
  MapType(const MapType&);
  MapType& operator=(const MapType&);
  MapType() {}

  virtual ~MapType() throw();

  bool operator==(const MapType& /* rhs */) const { return true; }
  bool operator!=(const MapType& rhs) const { return !(*this == rhs); }

  bool operator<(const MapType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MapType& a, MapType& b);

inline std::ostream& operator<<(std::ostream& out, const MapType& obj) {
  obj.printTo(out);
  return out;
}

class ListType : public virtual ::apache::thrift::TBase {
 public:
  ListType(const ListType&);
  ListType& operator=(const ListType&);
  ListType() {}

  virtual ~ListType() throw();

  bool operator==(const ListType& /* rhs */) const { return true; }
  bool operator!=(const ListType& rhs) const { return !(*this == rhs); }

  bool operator<(const ListType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListType& a, ListType& b);

inline std::ostream& operator<<(std::ostream& out, const ListType& obj) {
  obj.printTo(out);
  return out;
}

class EnumType : public virtual ::apache::thrift::TBase {
 public:
  EnumType(const EnumType&);
  EnumType& operator=(const EnumType&);
  EnumType() {}

  virtual ~EnumType() throw();

  bool operator==(const EnumType& /* rhs */) const { return true; }
  bool operator!=(const EnumType& rhs) const { return !(*this == rhs); }

  bool operator<(const EnumType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EnumType& a, EnumType& b);

inline std::ostream& operator<<(std::ostream& out, const EnumType& obj) {
  obj.printTo(out);
  return out;
}

class DateType : public virtual ::apache::thrift::TBase {
 public:
  DateType(const DateType&);
  DateType& operator=(const DateType&);
  DateType() {}

  virtual ~DateType() throw();

  bool operator==(const DateType& /* rhs */) const { return true; }
  bool operator!=(const DateType& rhs) const { return !(*this == rhs); }

  bool operator<(const DateType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DateType& a, DateType& b);

inline std::ostream& operator<<(std::ostream& out, const DateType& obj) {
  obj.printTo(out);
  return out;
}

class NullType : public virtual ::apache::thrift::TBase {
 public:
  NullType(const NullType&);
  NullType& operator=(const NullType&);
  NullType() {}

  virtual ~NullType() throw();

  bool operator==(const NullType& /* rhs */) const { return true; }
  bool operator!=(const NullType& rhs) const { return !(*this == rhs); }

  bool operator<(const NullType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NullType& a, NullType& b);

inline std::ostream& operator<<(std::ostream& out, const NullType& obj) {
  obj.printTo(out);
  return out;
}

class DecimalType : public virtual ::apache::thrift::TBase {
 public:
  DecimalType(const DecimalType&);
  DecimalType& operator=(const DecimalType&);
  DecimalType() : scale(0), precision(0) {}

  virtual ~DecimalType() throw();
  int32_t scale;
  int32_t precision;

  void __set_scale(const int32_t val);

  void __set_precision(const int32_t val);

  bool operator==(const DecimalType& rhs) const {
    if (!(scale == rhs.scale)) return false;
    if (!(precision == rhs.precision)) return false;
    return true;
  }
  bool operator!=(const DecimalType& rhs) const { return !(*this == rhs); }

  bool operator<(const DecimalType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DecimalType& a, DecimalType& b);

inline std::ostream& operator<<(std::ostream& out, const DecimalType& obj) {
  obj.printTo(out);
  return out;
}

class MilliSeconds : public virtual ::apache::thrift::TBase {
 public:
  MilliSeconds(const MilliSeconds&);
  MilliSeconds& operator=(const MilliSeconds&);
  MilliSeconds() {}

  virtual ~MilliSeconds() throw();

  bool operator==(const MilliSeconds& /* rhs */) const { return true; }
  bool operator!=(const MilliSeconds& rhs) const { return !(*this == rhs); }

  bool operator<(const MilliSeconds&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MilliSeconds& a, MilliSeconds& b);

inline std::ostream& operator<<(std::ostream& out, const MilliSeconds& obj) {
  obj.printTo(out);
  return out;
}

class MicroSeconds : public virtual ::apache::thrift::TBase {
 public:
  MicroSeconds(const MicroSeconds&);
  MicroSeconds& operator=(const MicroSeconds&);
  MicroSeconds() {}

  virtual ~MicroSeconds() throw();

  bool operator==(const MicroSeconds& /* rhs */) const { return true; }
  bool operator!=(const MicroSeconds& rhs) const { return !(*this == rhs); }

  bool operator<(const MicroSeconds&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MicroSeconds& a, MicroSeconds& b);

inline std::ostream& operator<<(std::ostream& out, const MicroSeconds& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _TimeUnit__isset {
  _TimeUnit__isset() : MILLIS(false), MICROS(false) {}
  bool MILLIS : 1;
  bool MICROS : 1;
} _TimeUnit__isset;

class TimeUnit : public virtual ::apache::thrift::TBase {
 public:
  TimeUnit(const TimeUnit&);
  TimeUnit& operator=(const TimeUnit&);
  TimeUnit() {}

  virtual ~TimeUnit() throw();
  MilliSeconds MILLIS;
  MicroSeconds MICROS;

  _TimeUnit__isset __isset;

  void __set_MILLIS(const MilliSeconds& val);

  void __set_MICROS(const MicroSeconds& val);

  bool operator==(const TimeUnit& rhs) const {
    if (__isset.MILLIS != rhs.__isset.MILLIS)
      return false;
    else if (__isset.MILLIS && !(MILLIS == rhs.MILLIS))
      return false;
    if (__isset.MICROS != rhs.__isset.MICROS)
      return false;
    else if (__isset.MICROS && !(MICROS == rhs.MICROS))
      return false;
    return true;
  }
  bool operator!=(const TimeUnit& rhs) const { return !(*this == rhs); }

  bool operator<(const TimeUnit&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimeUnit& a, TimeUnit& b);

inline std::ostream& operator<<(std::ostream& out, const TimeUnit& obj) {
  obj.printTo(out);
  return out;
}

class TimestampType : public virtual ::apache::thrift::TBase {
 public:
  TimestampType(const TimestampType&);
  TimestampType& operator=(const TimestampType&);
  TimestampType() : isAdjustedToUTC(0) {}

  virtual ~TimestampType() throw();
  bool isAdjustedToUTC;
  TimeUnit unit;

  void __set_isAdjustedToUTC(const bool val);

  void __set_unit(const TimeUnit& val);

  bool operator==(const TimestampType& rhs) const {
    if (!(isAdjustedToUTC == rhs.isAdjustedToUTC)) return false;
    if (!(unit == rhs.unit)) return false;
    return true;
  }
  bool operator!=(const TimestampType& rhs) const { return !(*this == rhs); }

  bool operator<(const TimestampType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimestampType& a, TimestampType& b);

inline std::ostream& operator<<(std::ostream& out, const TimestampType& obj) {
  obj.printTo(out);
  return out;
}

class TimeType : public virtual ::apache::thrift::TBase {
 public:
  TimeType(const TimeType&);
  TimeType& operator=(const TimeType&);
  TimeType() : isAdjustedToUTC(0) {}

  virtual ~TimeType() throw();
  bool isAdjustedToUTC;
  TimeUnit unit;

  void __set_isAdjustedToUTC(const bool val);

  void __set_unit(const TimeUnit& val);

  bool operator==(const TimeType& rhs) const {
    if (!(isAdjustedToUTC == rhs.isAdjustedToUTC)) return false;
    if (!(unit == rhs.unit)) return false;
    return true;
  }
  bool operator!=(const TimeType& rhs) const { return !(*this == rhs); }

  bool operator<(const TimeType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimeType& a, TimeType& b);

inline std::ostream& operator<<(std::ostream& out, const TimeType& obj) {
  obj.printTo(out);
  return out;
}

class IntType : public virtual ::apache::thrift::TBase {
 public:
  IntType(const IntType&);
  IntType& operator=(const IntType&);
  IntType() : bitWidth(0), isSigned(0) {}

  virtual ~IntType() throw();
  int8_t bitWidth;
  bool isSigned;

  void __set_bitWidth(const int8_t val);

  void __set_isSigned(const bool val);

  bool operator==(const IntType& rhs) const {
    if (!(bitWidth == rhs.bitWidth)) return false;
    if (!(isSigned == rhs.isSigned)) return false;
    return true;
  }
  bool operator!=(const IntType& rhs) const { return !(*this == rhs); }

  bool operator<(const IntType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntType& a, IntType& b);

inline std::ostream& operator<<(std::ostream& out, const IntType& obj) {
  obj.printTo(out);
  return out;
}

class JsonType : public virtual ::apache::thrift::TBase {
 public:
  JsonType(const JsonType&);
  JsonType& operator=(const JsonType&);
  JsonType() {}

  virtual ~JsonType() throw();

  bool operator==(const JsonType& /* rhs */) const { return true; }
  bool operator!=(const JsonType& rhs) const { return !(*this == rhs); }

  bool operator<(const JsonType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(JsonType& a, JsonType& b);

inline std::ostream& operator<<(std::ostream& out, const JsonType& obj) {
  obj.printTo(out);
  return out;
}

class BsonType : public virtual ::apache::thrift::TBase {
 public:
  BsonType(const BsonType&);
  BsonType& operator=(const BsonType&);
  BsonType() {}

  virtual ~BsonType() throw();

  bool operator==(const BsonType& /* rhs */) const { return true; }
  bool operator!=(const BsonType& rhs) const { return !(*this == rhs); }

  bool operator<(const BsonType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BsonType& a, BsonType& b);

inline std::ostream& operator<<(std::ostream& out, const BsonType& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _LogicalType__isset {
  _LogicalType__isset()
      : STRING(false),
        MAP(false),
        LIST(false),
        ENUM(false),
        DECIMAL(false),
        DATE(false),
        TIME(false),
        TIMESTAMP(false),
        INTEGER(false),
        UNKNOWN(false),
        JSON(false),
        BSON(false) {}
  bool STRING : 1;
  bool MAP : 1;
  bool LIST : 1;
  bool ENUM : 1;
  bool DECIMAL : 1;
  bool DATE : 1;
  bool TIME : 1;
  bool TIMESTAMP : 1;
  bool INTEGER : 1;
  bool UNKNOWN : 1;
  bool JSON : 1;
  bool BSON : 1;
} _LogicalType__isset;

class LogicalType : public virtual ::apache::thrift::TBase {
 public:
  LogicalType(const LogicalType&);
  LogicalType& operator=(const LogicalType&);
  LogicalType() {}

  virtual ~LogicalType() throw();
  StringType STRING;
  MapType MAP;
  ListType LIST;
  EnumType ENUM;
  DecimalType DECIMAL;
  DateType DATE;
  TimeType TIME;
  TimestampType TIMESTAMP;
  IntType INTEGER;
  NullType UNKNOWN;
  JsonType JSON;
  BsonType BSON;

  _LogicalType__isset __isset;

  void __set_STRING(const StringType& val);

  void __set_MAP(const MapType& val);

  void __set_LIST(const ListType& val);

  void __set_ENUM(const EnumType& val);

  void __set_DECIMAL(const DecimalType& val);

  void __set_DATE(const DateType& val);

  void __set_TIME(const TimeType& val);

  void __set_TIMESTAMP(const TimestampType& val);

  void __set_INTEGER(const IntType& val);

  void __set_UNKNOWN(const NullType& val);

  void __set_JSON(const JsonType& val);

  void __set_BSON(const BsonType& val);

  bool operator==(const LogicalType& rhs) const {
    if (__isset.STRING != rhs.__isset.STRING)
      return false;
    else if (__isset.STRING && !(STRING == rhs.STRING))
      return false;
    if (__isset.MAP != rhs.__isset.MAP)
      return false;
    else if (__isset.MAP && !(MAP == rhs.MAP))
      return false;
    if (__isset.LIST != rhs.__isset.LIST)
      return false;
    else if (__isset.LIST && !(LIST == rhs.LIST))
      return false;
    if (__isset.ENUM != rhs.__isset.ENUM)
      return false;
    else if (__isset.ENUM && !(ENUM == rhs.ENUM))
      return false;
    if (__isset.DECIMAL != rhs.__isset.DECIMAL)
      return false;
    else if (__isset.DECIMAL && !(DECIMAL == rhs.DECIMAL))
      return false;
    if (__isset.DATE != rhs.__isset.DATE)
      return false;
    else if (__isset.DATE && !(DATE == rhs.DATE))
      return false;
    if (__isset.TIME != rhs.__isset.TIME)
      return false;
    else if (__isset.TIME && !(TIME == rhs.TIME))
      return false;
    if (__isset.TIMESTAMP != rhs.__isset.TIMESTAMP)
      return false;
    else if (__isset.TIMESTAMP && !(TIMESTAMP == rhs.TIMESTAMP))
      return false;
    if (__isset.INTEGER != rhs.__isset.INTEGER)
      return false;
    else if (__isset.INTEGER && !(INTEGER == rhs.INTEGER))
      return false;
    if (__isset.UNKNOWN != rhs.__isset.UNKNOWN)
      return false;
    else if (__isset.UNKNOWN && !(UNKNOWN == rhs.UNKNOWN))
      return false;
    if (__isset.JSON != rhs.__isset.JSON)
      return false;
    else if (__isset.JSON && !(JSON == rhs.JSON))
      return false;
    if (__isset.BSON != rhs.__isset.BSON)
      return false;
    else if (__isset.BSON && !(BSON == rhs.BSON))
      return false;
    return true;
  }
  bool operator!=(const LogicalType& rhs) const { return !(*this == rhs); }

  bool operator<(const LogicalType&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LogicalType& a, LogicalType& b);

inline std::ostream& operator<<(std::ostream& out, const LogicalType& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _SchemaElement__isset {
  _SchemaElement__isset()
      : type(false),
        type_length(false),
        repetition_type(false),
        num_children(false),
        converted_type(false),
        scale(false),
        precision(false),
        field_id(false),
        logicalType(false) {}
  bool type : 1;
  bool type_length : 1;
  bool repetition_type : 1;
  bool num_children : 1;
  bool converted_type : 1;
  bool scale : 1;
  bool precision : 1;
  bool field_id : 1;
  bool logicalType : 1;
} _SchemaElement__isset;

class SchemaElement : public virtual ::apache::thrift::TBase {
 public:
  SchemaElement(const SchemaElement&);
  SchemaElement& operator=(const SchemaElement&);
  SchemaElement()
      : type((Type::type)0),
        type_length(0),
        repetition_type((FieldRepetitionType::type)0),
        name(),
        num_children(0),
        converted_type((ConvertedType::type)0),
        scale(0),
        precision(0),
        field_id(0) {}

  virtual ~SchemaElement() throw();
  Type::type type;
  int32_t type_length;
  FieldRepetitionType::type repetition_type;
  std::string name;
  int32_t num_children;
  ConvertedType::type converted_type;
  int32_t scale;
  int32_t precision;
  int32_t field_id;
  LogicalType logicalType;

  _SchemaElement__isset __isset;

  void __set_type(const Type::type val);

  void __set_type_length(const int32_t val);

  void __set_repetition_type(const FieldRepetitionType::type val);

  void __set_name(const std::string& val);

  void __set_num_children(const int32_t val);

  void __set_converted_type(const ConvertedType::type val);

  void __set_scale(const int32_t val);

  void __set_precision(const int32_t val);

  void __set_field_id(const int32_t val);

  void __set_logicalType(const LogicalType& val);

  bool operator==(const SchemaElement& rhs) const {
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.type_length != rhs.__isset.type_length)
      return false;
    else if (__isset.type_length && !(type_length == rhs.type_length))
      return false;
    if (__isset.repetition_type != rhs.__isset.repetition_type)
      return false;
    else if (__isset.repetition_type &&
             !(repetition_type == rhs.repetition_type))
      return false;
    if (!(name == rhs.name)) return false;
    if (__isset.num_children != rhs.__isset.num_children)
      return false;
    else if (__isset.num_children && !(num_children == rhs.num_children))
      return false;
    if (__isset.converted_type != rhs.__isset.converted_type)
      return false;
    else if (__isset.converted_type && !(converted_type == rhs.converted_type))
      return false;
    if (__isset.scale != rhs.__isset.scale)
      return false;
    else if (__isset.scale && !(scale == rhs.scale))
      return false;
    if (__isset.precision != rhs.__isset.precision)
      return false;
    else if (__isset.precision && !(precision == rhs.precision))
      return false;
    if (__isset.field_id != rhs.__isset.field_id)
      return false;
    else if (__isset.field_id && !(field_id == rhs.field_id))
      return false;
    if (__isset.logicalType != rhs.__isset.logicalType)
      return false;
    else if (__isset.logicalType && !(logicalType == rhs.logicalType))
      return false;
    return true;
  }
  bool operator!=(const SchemaElement& rhs) const { return !(*this == rhs); }

  bool operator<(const SchemaElement&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaElement& a, SchemaElement& b);

inline std::ostream& operator<<(std::ostream& out, const SchemaElement& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _DataPageHeader__isset {
  _DataPageHeader__isset() : statistics(false) {}
  bool statistics : 1;
} _DataPageHeader__isset;

class DataPageHeader : public virtual ::apache::thrift::TBase {
 public:
  DataPageHeader(const DataPageHeader&);
  DataPageHeader& operator=(const DataPageHeader&);
  DataPageHeader()
      : num_values(0),
        encoding((Encoding::type)0),
        definition_level_encoding((Encoding::type)0),
        repetition_level_encoding((Encoding::type)0) {}

  virtual ~DataPageHeader() throw();
  int32_t num_values;
  Encoding::type encoding;
  Encoding::type definition_level_encoding;
  Encoding::type repetition_level_encoding;
  Statistics statistics;

  _DataPageHeader__isset __isset;

  void __set_num_values(const int32_t val);

  void __set_encoding(const Encoding::type val);

  void __set_definition_level_encoding(const Encoding::type val);

  void __set_repetition_level_encoding(const Encoding::type val);

  void __set_statistics(const Statistics& val);

  bool operator==(const DataPageHeader& rhs) const {
    if (!(num_values == rhs.num_values)) return false;
    if (!(encoding == rhs.encoding)) return false;
    if (!(definition_level_encoding == rhs.definition_level_encoding))
      return false;
    if (!(repetition_level_encoding == rhs.repetition_level_encoding))
      return false;
    if (__isset.statistics != rhs.__isset.statistics)
      return false;
    else if (__isset.statistics && !(statistics == rhs.statistics))
      return false;
    return true;
  }
  bool operator!=(const DataPageHeader& rhs) const { return !(*this == rhs); }

  bool operator<(const DataPageHeader&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataPageHeader& a, DataPageHeader& b);

inline std::ostream& operator<<(std::ostream& out, const DataPageHeader& obj) {
  obj.printTo(out);
  return out;
}

class IndexPageHeader : public virtual ::apache::thrift::TBase {
 public:
  IndexPageHeader(const IndexPageHeader&);
  IndexPageHeader& operator=(const IndexPageHeader&);
  IndexPageHeader() {}

  virtual ~IndexPageHeader() throw();

  bool operator==(const IndexPageHeader& /* rhs */) const { return true; }
  bool operator!=(const IndexPageHeader& rhs) const { return !(*this == rhs); }

  bool operator<(const IndexPageHeader&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IndexPageHeader& a, IndexPageHeader& b);

inline std::ostream& operator<<(std::ostream& out, const IndexPageHeader& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _DictionaryPageHeader__isset {
  _DictionaryPageHeader__isset() : is_sorted(false) {}
  bool is_sorted : 1;
} _DictionaryPageHeader__isset;

class DictionaryPageHeader : public virtual ::apache::thrift::TBase {
 public:
  DictionaryPageHeader(const DictionaryPageHeader&);
  DictionaryPageHeader& operator=(const DictionaryPageHeader&);
  DictionaryPageHeader()
      : num_values(0), encoding((Encoding::type)0), is_sorted(0) {}

  virtual ~DictionaryPageHeader() throw();
  int32_t num_values;
  Encoding::type encoding;
  bool is_sorted;

  _DictionaryPageHeader__isset __isset;

  void __set_num_values(const int32_t val);

  void __set_encoding(const Encoding::type val);

  void __set_is_sorted(const bool val);

  bool operator==(const DictionaryPageHeader& rhs) const {
    if (!(num_values == rhs.num_values)) return false;
    if (!(encoding == rhs.encoding)) return false;
    if (__isset.is_sorted != rhs.__isset.is_sorted)
      return false;
    else if (__isset.is_sorted && !(is_sorted == rhs.is_sorted))
      return false;
    return true;
  }
  bool operator!=(const DictionaryPageHeader& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const DictionaryPageHeader&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DictionaryPageHeader& a, DictionaryPageHeader& b);

inline std::ostream& operator<<(std::ostream& out,
                                const DictionaryPageHeader& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _DataPageHeaderV2__isset {
  _DataPageHeaderV2__isset() : is_compressed(true), statistics(false) {}
  bool is_compressed : 1;
  bool statistics : 1;
} _DataPageHeaderV2__isset;

class DataPageHeaderV2 : public virtual ::apache::thrift::TBase {
 public:
  DataPageHeaderV2(const DataPageHeaderV2&);
  DataPageHeaderV2& operator=(const DataPageHeaderV2&);
  DataPageHeaderV2()
      : num_values(0),
        num_nulls(0),
        num_rows(0),
        encoding((Encoding::type)0),
        definition_levels_byte_length(0),
        repetition_levels_byte_length(0),
        is_compressed(true) {}

  virtual ~DataPageHeaderV2() throw();
  int32_t num_values;
  int32_t num_nulls;
  int32_t num_rows;
  Encoding::type encoding;
  int32_t definition_levels_byte_length;
  int32_t repetition_levels_byte_length;
  bool is_compressed;
  Statistics statistics;

  _DataPageHeaderV2__isset __isset;

  void __set_num_values(const int32_t val);

  void __set_num_nulls(const int32_t val);

  void __set_num_rows(const int32_t val);

  void __set_encoding(const Encoding::type val);

  void __set_definition_levels_byte_length(const int32_t val);

  void __set_repetition_levels_byte_length(const int32_t val);

  void __set_is_compressed(const bool val);

  void __set_statistics(const Statistics& val);

  bool operator==(const DataPageHeaderV2& rhs) const {
    if (!(num_values == rhs.num_values)) return false;
    if (!(num_nulls == rhs.num_nulls)) return false;
    if (!(num_rows == rhs.num_rows)) return false;
    if (!(encoding == rhs.encoding)) return false;
    if (!(definition_levels_byte_length == rhs.definition_levels_byte_length))
      return false;
    if (!(repetition_levels_byte_length == rhs.repetition_levels_byte_length))
      return false;
    if (__isset.is_compressed != rhs.__isset.is_compressed)
      return false;
    else if (__isset.is_compressed && !(is_compressed == rhs.is_compressed))
      return false;
    if (__isset.statistics != rhs.__isset.statistics)
      return false;
    else if (__isset.statistics && !(statistics == rhs.statistics))
      return false;
    return true;
  }
  bool operator!=(const DataPageHeaderV2& rhs) const { return !(*this == rhs); }

  bool operator<(const DataPageHeaderV2&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataPageHeaderV2& a, DataPageHeaderV2& b);

inline std::ostream& operator<<(std::ostream& out,
                                const DataPageHeaderV2& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _PageHeader__isset {
  _PageHeader__isset()
      : crc(false),
        data_page_header(false),
        index_page_header(false),
        dictionary_page_header(false),
        data_page_header_v2(false) {}
  bool crc : 1;
  bool data_page_header : 1;
  bool index_page_header : 1;
  bool dictionary_page_header : 1;
  bool data_page_header_v2 : 1;
} _PageHeader__isset;

class PageHeader : public virtual ::apache::thrift::TBase {
 public:
  PageHeader(const PageHeader&);
  PageHeader& operator=(const PageHeader&);
  PageHeader()
      : type((PageType::type)0),
        uncompressed_page_size(0),
        compressed_page_size(0),
        crc(0) {}

  virtual ~PageHeader() throw();
  PageType::type type;
  int32_t uncompressed_page_size;
  int32_t compressed_page_size;
  int32_t crc;
  DataPageHeader data_page_header;
  IndexPageHeader index_page_header;
  DictionaryPageHeader dictionary_page_header;
  DataPageHeaderV2 data_page_header_v2;

  _PageHeader__isset __isset;

  void __set_type(const PageType::type val);

  void __set_uncompressed_page_size(const int32_t val);

  void __set_compressed_page_size(const int32_t val);

  void __set_crc(const int32_t val);

  void __set_data_page_header(const DataPageHeader& val);

  void __set_index_page_header(const IndexPageHeader& val);

  void __set_dictionary_page_header(const DictionaryPageHeader& val);

  void __set_data_page_header_v2(const DataPageHeaderV2& val);

  bool operator==(const PageHeader& rhs) const {
    if (!(type == rhs.type)) return false;
    if (!(uncompressed_page_size == rhs.uncompressed_page_size)) return false;
    if (!(compressed_page_size == rhs.compressed_page_size)) return false;
    if (__isset.crc != rhs.__isset.crc)
      return false;
    else if (__isset.crc && !(crc == rhs.crc))
      return false;
    if (__isset.data_page_header != rhs.__isset.data_page_header)
      return false;
    else if (__isset.data_page_header &&
             !(data_page_header == rhs.data_page_header))
      return false;
    if (__isset.index_page_header != rhs.__isset.index_page_header)
      return false;
    else if (__isset.index_page_header &&
             !(index_page_header == rhs.index_page_header))
      return false;
    if (__isset.dictionary_page_header != rhs.__isset.dictionary_page_header)
      return false;
    else if (__isset.dictionary_page_header &&
             !(dictionary_page_header == rhs.dictionary_page_header))
      return false;
    if (__isset.data_page_header_v2 != rhs.__isset.data_page_header_v2)
      return false;
    else if (__isset.data_page_header_v2 &&
             !(data_page_header_v2 == rhs.data_page_header_v2))
      return false;
    return true;
  }
  bool operator!=(const PageHeader& rhs) const { return !(*this == rhs); }

  bool operator<(const PageHeader&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PageHeader& a, PageHeader& b);

inline std::ostream& operator<<(std::ostream& out, const PageHeader& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _KeyValue__isset {
  _KeyValue__isset() : value(false) {}
  bool value : 1;
} _KeyValue__isset;

class KeyValue : public virtual ::apache::thrift::TBase {
 public:
  KeyValue(const KeyValue&);
  KeyValue& operator=(const KeyValue&);
  KeyValue() : key(), value() {}

  virtual ~KeyValue() throw();
  std::string key;
  std::string value;

  _KeyValue__isset __isset;

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  bool operator==(const KeyValue& rhs) const {
    if (!(key == rhs.key)) return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator!=(const KeyValue& rhs) const { return !(*this == rhs); }

  bool operator<(const KeyValue&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(KeyValue& a, KeyValue& b);

inline std::ostream& operator<<(std::ostream& out, const KeyValue& obj) {
  obj.printTo(out);
  return out;
}

class SortingColumn : public virtual ::apache::thrift::TBase {
 public:
  SortingColumn(const SortingColumn&);
  SortingColumn& operator=(const SortingColumn&);
  SortingColumn() : column_idx(0), descending(0), nulls_first(0) {}

  virtual ~SortingColumn() throw();
  int32_t column_idx;
  bool descending;
  bool nulls_first;

  void __set_column_idx(const int32_t val);

  void __set_descending(const bool val);

  void __set_nulls_first(const bool val);

  bool operator==(const SortingColumn& rhs) const {
    if (!(column_idx == rhs.column_idx)) return false;
    if (!(descending == rhs.descending)) return false;
    if (!(nulls_first == rhs.nulls_first)) return false;
    return true;
  }
  bool operator!=(const SortingColumn& rhs) const { return !(*this == rhs); }

  bool operator<(const SortingColumn&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SortingColumn& a, SortingColumn& b);

inline std::ostream& operator<<(std::ostream& out, const SortingColumn& obj) {
  obj.printTo(out);
  return out;
}

class PageEncodingStats : public virtual ::apache::thrift::TBase {
 public:
  PageEncodingStats(const PageEncodingStats&);
  PageEncodingStats& operator=(const PageEncodingStats&);
  PageEncodingStats()
      : page_type((PageType::type)0), encoding((Encoding::type)0), count(0) {}

  virtual ~PageEncodingStats() throw();
  PageType::type page_type;
  Encoding::type encoding;
  int32_t count;

  void __set_page_type(const PageType::type val);

  void __set_encoding(const Encoding::type val);

  void __set_count(const int32_t val);

  bool operator==(const PageEncodingStats& rhs) const {
    if (!(page_type == rhs.page_type)) return false;
    if (!(encoding == rhs.encoding)) return false;
    if (!(count == rhs.count)) return false;
    return true;
  }
  bool operator!=(const PageEncodingStats& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const PageEncodingStats&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PageEncodingStats& a, PageEncodingStats& b);

inline std::ostream& operator<<(std::ostream& out,
                                const PageEncodingStats& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _ColumnMetaData__isset {
  _ColumnMetaData__isset()
      : key_value_metadata(false),
        index_page_offset(false),
        dictionary_page_offset(false),
        statistics(false),
        encoding_stats(false) {}
  bool key_value_metadata : 1;
  bool index_page_offset : 1;
  bool dictionary_page_offset : 1;
  bool statistics : 1;
  bool encoding_stats : 1;
} _ColumnMetaData__isset;

class ColumnMetaData : public virtual ::apache::thrift::TBase {
 public:
  ColumnMetaData(const ColumnMetaData&);
  ColumnMetaData& operator=(const ColumnMetaData&);
  ColumnMetaData()
      : type((Type::type)0),
        codec((CompressionCodec::type)0),
        num_values(0),
        total_uncompressed_size(0),
        total_compressed_size(0),
        data_page_offset(0),
        index_page_offset(0),
        dictionary_page_offset(0) {}

  virtual ~ColumnMetaData() throw();
  Type::type type;
  std::vector<Encoding::type> encodings;
  std::vector<std::string> path_in_schema;
  CompressionCodec::type codec;
  int64_t num_values;
  int64_t total_uncompressed_size;
  int64_t total_compressed_size;
  std::vector<KeyValue> key_value_metadata;
  int64_t data_page_offset;
  int64_t index_page_offset;
  int64_t dictionary_page_offset;
  Statistics statistics;
  std::vector<PageEncodingStats> encoding_stats;

  _ColumnMetaData__isset __isset;

  void __set_type(const Type::type val);

  void __set_encodings(const std::vector<Encoding::type>& val);

  void __set_path_in_schema(const std::vector<std::string>& val);

  void __set_codec(const CompressionCodec::type val);

  void __set_num_values(const int64_t val);

  void __set_total_uncompressed_size(const int64_t val);

  void __set_total_compressed_size(const int64_t val);

  void __set_key_value_metadata(const std::vector<KeyValue>& val);

  void __set_data_page_offset(const int64_t val);

  void __set_index_page_offset(const int64_t val);

  void __set_dictionary_page_offset(const int64_t val);

  void __set_statistics(const Statistics& val);

  void __set_encoding_stats(const std::vector<PageEncodingStats>& val);

  bool operator==(const ColumnMetaData& rhs) const {
    if (!(type == rhs.type)) return false;
    if (!(encodings == rhs.encodings)) return false;
    if (!(path_in_schema == rhs.path_in_schema)) return false;
    if (!(codec == rhs.codec)) return false;
    if (!(num_values == rhs.num_values)) return false;
    if (!(total_uncompressed_size == rhs.total_uncompressed_size)) return false;
    if (!(total_compressed_size == rhs.total_compressed_size)) return false;
    if (__isset.key_value_metadata != rhs.__isset.key_value_metadata)
      return false;
    else if (__isset.key_value_metadata &&
             !(key_value_metadata == rhs.key_value_metadata))
      return false;
    if (!(data_page_offset == rhs.data_page_offset)) return false;
    if (__isset.index_page_offset != rhs.__isset.index_page_offset)
      return false;
    else if (__isset.index_page_offset &&
             !(index_page_offset == rhs.index_page_offset))
      return false;
    if (__isset.dictionary_page_offset != rhs.__isset.dictionary_page_offset)
      return false;
    else if (__isset.dictionary_page_offset &&
             !(dictionary_page_offset == rhs.dictionary_page_offset))
      return false;
    if (__isset.statistics != rhs.__isset.statistics)
      return false;
    else if (__isset.statistics && !(statistics == rhs.statistics))
      return false;
    if (__isset.encoding_stats != rhs.__isset.encoding_stats)
      return false;
    else if (__isset.encoding_stats && !(encoding_stats == rhs.encoding_stats))
      return false;
    return true;
  }
  bool operator!=(const ColumnMetaData& rhs) const { return !(*this == rhs); }

  bool operator<(const ColumnMetaData&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnMetaData& a, ColumnMetaData& b);

inline std::ostream& operator<<(std::ostream& out, const ColumnMetaData& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _ColumnChunk__isset {
  _ColumnChunk__isset()
      : file_path(false),
        meta_data(false),
        offset_index_offset(false),
        offset_index_length(false),
        column_index_offset(false),
        column_index_length(false) {}
  bool file_path : 1;
  bool meta_data : 1;
  bool offset_index_offset : 1;
  bool offset_index_length : 1;
  bool column_index_offset : 1;
  bool column_index_length : 1;
} _ColumnChunk__isset;

class ColumnChunk : public virtual ::apache::thrift::TBase {
 public:
  ColumnChunk(const ColumnChunk&);
  ColumnChunk& operator=(const ColumnChunk&);
  ColumnChunk()
      : file_path(),
        file_offset(0),
        offset_index_offset(0),
        offset_index_length(0),
        column_index_offset(0),
        column_index_length(0) {}

  virtual ~ColumnChunk() throw();
  std::string file_path;
  int64_t file_offset;
  ColumnMetaData meta_data;
  int64_t offset_index_offset;
  int32_t offset_index_length;
  int64_t column_index_offset;
  int32_t column_index_length;

  _ColumnChunk__isset __isset;

  void __set_file_path(const std::string& val);

  void __set_file_offset(const int64_t val);

  void __set_meta_data(const ColumnMetaData& val);

  void __set_offset_index_offset(const int64_t val);

  void __set_offset_index_length(const int32_t val);

  void __set_column_index_offset(const int64_t val);

  void __set_column_index_length(const int32_t val);

  bool operator==(const ColumnChunk& rhs) const {
    if (__isset.file_path != rhs.__isset.file_path)
      return false;
    else if (__isset.file_path && !(file_path == rhs.file_path))
      return false;
    if (!(file_offset == rhs.file_offset)) return false;
    if (__isset.meta_data != rhs.__isset.meta_data)
      return false;
    else if (__isset.meta_data && !(meta_data == rhs.meta_data))
      return false;
    if (__isset.offset_index_offset != rhs.__isset.offset_index_offset)
      return false;
    else if (__isset.offset_index_offset &&
             !(offset_index_offset == rhs.offset_index_offset))
      return false;
    if (__isset.offset_index_length != rhs.__isset.offset_index_length)
      return false;
    else if (__isset.offset_index_length &&
             !(offset_index_length == rhs.offset_index_length))
      return false;
    if (__isset.column_index_offset != rhs.__isset.column_index_offset)
      return false;
    else if (__isset.column_index_offset &&
             !(column_index_offset == rhs.column_index_offset))
      return false;
    if (__isset.column_index_length != rhs.__isset.column_index_length)
      return false;
    else if (__isset.column_index_length &&
             !(column_index_length == rhs.column_index_length))
      return false;
    return true;
  }
  bool operator!=(const ColumnChunk& rhs) const { return !(*this == rhs); }

  bool operator<(const ColumnChunk&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnChunk& a, ColumnChunk& b);

inline std::ostream& operator<<(std::ostream& out, const ColumnChunk& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _RowGroup__isset {
  _RowGroup__isset() : sorting_columns(false) {}
  bool sorting_columns : 1;
} _RowGroup__isset;

class RowGroup : public virtual ::apache::thrift::TBase {
 public:
  RowGroup(const RowGroup&);
  RowGroup& operator=(const RowGroup&);
  RowGroup() : total_byte_size(0), num_rows(0) {}

  virtual ~RowGroup() throw();
  std::vector<ColumnChunk> columns;
  int64_t total_byte_size;
  int64_t num_rows;
  std::vector<SortingColumn> sorting_columns;

  _RowGroup__isset __isset;

  void __set_columns(const std::vector<ColumnChunk>& val);

  void __set_total_byte_size(const int64_t val);

  void __set_num_rows(const int64_t val);

  void __set_sorting_columns(const std::vector<SortingColumn>& val);

  bool operator==(const RowGroup& rhs) const {
    if (!(columns == rhs.columns)) return false;
    if (!(total_byte_size == rhs.total_byte_size)) return false;
    if (!(num_rows == rhs.num_rows)) return false;
    if (__isset.sorting_columns != rhs.__isset.sorting_columns)
      return false;
    else if (__isset.sorting_columns &&
             !(sorting_columns == rhs.sorting_columns))
      return false;
    return true;
  }
  bool operator!=(const RowGroup& rhs) const { return !(*this == rhs); }

  bool operator<(const RowGroup&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RowGroup& a, RowGroup& b);

inline std::ostream& operator<<(std::ostream& out, const RowGroup& obj) {
  obj.printTo(out);
  return out;
}

class TypeDefinedOrder : public virtual ::apache::thrift::TBase {
 public:
  TypeDefinedOrder(const TypeDefinedOrder&);
  TypeDefinedOrder& operator=(const TypeDefinedOrder&);
  TypeDefinedOrder() {}

  virtual ~TypeDefinedOrder() throw();

  bool operator==(const TypeDefinedOrder& /* rhs */) const { return true; }
  bool operator!=(const TypeDefinedOrder& rhs) const { return !(*this == rhs); }

  bool operator<(const TypeDefinedOrder&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TypeDefinedOrder& a, TypeDefinedOrder& b);

inline std::ostream& operator<<(std::ostream& out,
                                const TypeDefinedOrder& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _ColumnOrder__isset {
  _ColumnOrder__isset() : TYPE_ORDER(false) {}
  bool TYPE_ORDER : 1;
} _ColumnOrder__isset;

class ColumnOrder : public virtual ::apache::thrift::TBase {
 public:
  ColumnOrder(const ColumnOrder&);
  ColumnOrder& operator=(const ColumnOrder&);
  ColumnOrder() {}

  virtual ~ColumnOrder() throw();
  TypeDefinedOrder TYPE_ORDER;

  _ColumnOrder__isset __isset;

  void __set_TYPE_ORDER(const TypeDefinedOrder& val);

  bool operator==(const ColumnOrder& rhs) const {
    if (__isset.TYPE_ORDER != rhs.__isset.TYPE_ORDER)
      return false;
    else if (__isset.TYPE_ORDER && !(TYPE_ORDER == rhs.TYPE_ORDER))
      return false;
    return true;
  }
  bool operator!=(const ColumnOrder& rhs) const { return !(*this == rhs); }

  bool operator<(const ColumnOrder&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnOrder& a, ColumnOrder& b);

inline std::ostream& operator<<(std::ostream& out, const ColumnOrder& obj) {
  obj.printTo(out);
  return out;
}

class PageLocation : public virtual ::apache::thrift::TBase {
 public:
  PageLocation(const PageLocation&);
  PageLocation& operator=(const PageLocation&);
  PageLocation() : offset(0), compressed_page_size(0), first_row_index(0) {}

  virtual ~PageLocation() throw();
  int64_t offset;
  int32_t compressed_page_size;
  int64_t first_row_index;

  void __set_offset(const int64_t val);

  void __set_compressed_page_size(const int32_t val);

  void __set_first_row_index(const int64_t val);

  bool operator==(const PageLocation& rhs) const {
    if (!(offset == rhs.offset)) return false;
    if (!(compressed_page_size == rhs.compressed_page_size)) return false;
    if (!(first_row_index == rhs.first_row_index)) return false;
    return true;
  }
  bool operator!=(const PageLocation& rhs) const { return !(*this == rhs); }

  bool operator<(const PageLocation&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PageLocation& a, PageLocation& b);

inline std::ostream& operator<<(std::ostream& out, const PageLocation& obj) {
  obj.printTo(out);
  return out;
}

class OffsetIndex : public virtual ::apache::thrift::TBase {
 public:
  OffsetIndex(const OffsetIndex&);
  OffsetIndex& operator=(const OffsetIndex&);
  OffsetIndex() {}

  virtual ~OffsetIndex() throw();
  std::vector<PageLocation> page_locations;

  void __set_page_locations(const std::vector<PageLocation>& val);

  bool operator==(const OffsetIndex& rhs) const {
    if (!(page_locations == rhs.page_locations)) return false;
    return true;
  }
  bool operator!=(const OffsetIndex& rhs) const { return !(*this == rhs); }

  bool operator<(const OffsetIndex&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OffsetIndex& a, OffsetIndex& b);

inline std::ostream& operator<<(std::ostream& out, const OffsetIndex& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _ColumnIndex__isset {
  _ColumnIndex__isset() : null_counts(false) {}
  bool null_counts : 1;
} _ColumnIndex__isset;

class ColumnIndex : public virtual ::apache::thrift::TBase {
 public:
  ColumnIndex(const ColumnIndex&);
  ColumnIndex& operator=(const ColumnIndex&);
  ColumnIndex() : boundary_order((BoundaryOrder::type)0) {}

  virtual ~ColumnIndex() throw();
  std::vector<bool> null_pages;
  std::vector<std::string> min_values;
  std::vector<std::string> max_values;
  BoundaryOrder::type boundary_order;
  std::vector<int64_t> null_counts;

  _ColumnIndex__isset __isset;

  void __set_null_pages(const std::vector<bool>& val);

  void __set_min_values(const std::vector<std::string>& val);

  void __set_max_values(const std::vector<std::string>& val);

  void __set_boundary_order(const BoundaryOrder::type val);

  void __set_null_counts(const std::vector<int64_t>& val);

  bool operator==(const ColumnIndex& rhs) const {
    if (!(null_pages == rhs.null_pages)) return false;
    if (!(min_values == rhs.min_values)) return false;
    if (!(max_values == rhs.max_values)) return false;
    if (!(boundary_order == rhs.boundary_order)) return false;
    if (__isset.null_counts != rhs.__isset.null_counts)
      return false;
    else if (__isset.null_counts && !(null_counts == rhs.null_counts))
      return false;
    return true;
  }
  bool operator!=(const ColumnIndex& rhs) const { return !(*this == rhs); }

  bool operator<(const ColumnIndex&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnIndex& a, ColumnIndex& b);

inline std::ostream& operator<<(std::ostream& out, const ColumnIndex& obj) {
  obj.printTo(out);
  return out;
}

typedef struct _FileMetaData__isset {
  _FileMetaData__isset()
      : key_value_metadata(false), created_by(false), column_orders(false) {}
  bool key_value_metadata : 1;
  bool created_by : 1;
  bool column_orders : 1;
} _FileMetaData__isset;

class FileMetaData : public virtual ::apache::thrift::TBase {
 public:
  FileMetaData(const FileMetaData&);
  FileMetaData& operator=(const FileMetaData&);
  FileMetaData() : version(0), num_rows(0), created_by() {}

  virtual ~FileMetaData() throw();
  int32_t version;
  std::vector<SchemaElement> schema;
  int64_t num_rows;
  std::vector<RowGroup> row_groups;
  std::vector<KeyValue> key_value_metadata;
  std::string created_by;
  std::vector<ColumnOrder> column_orders;

  _FileMetaData__isset __isset;

  void __set_version(const int32_t val);

  void __set_schema(const std::vector<SchemaElement>& val);

  void __set_num_rows(const int64_t val);

  void __set_row_groups(const std::vector<RowGroup>& val);

  void __set_key_value_metadata(const std::vector<KeyValue>& val);

  void __set_created_by(const std::string& val);

  void __set_column_orders(const std::vector<ColumnOrder>& val);

  bool operator==(const FileMetaData& rhs) const {
    if (!(version == rhs.version)) return false;
    if (!(schema == rhs.schema)) return false;
    if (!(num_rows == rhs.num_rows)) return false;
    if (!(row_groups == rhs.row_groups)) return false;
    if (__isset.key_value_metadata != rhs.__isset.key_value_metadata)
      return false;
    else if (__isset.key_value_metadata &&
             !(key_value_metadata == rhs.key_value_metadata))
      return false;
    if (__isset.created_by != rhs.__isset.created_by)
      return false;
    else if (__isset.created_by && !(created_by == rhs.created_by))
      return false;
    if (__isset.column_orders != rhs.__isset.column_orders)
      return false;
    else if (__isset.column_orders && !(column_orders == rhs.column_orders))
      return false;
    return true;
  }
  bool operator!=(const FileMetaData& rhs) const { return !(*this == rhs); }

  bool operator<(const FileMetaData&) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FileMetaData& a, FileMetaData& b);

inline std::ostream& operator<<(std::ostream& out, const FileMetaData& obj) {
  obj.printTo(out);
  return out;
}

}  // namespace

#endif
